在 Rust 中，`static` 和 `const` 都用于定义常量值，但它们有不同的语义和使用场景。以下是它们的主要区别：

---

### **1. `const`（编译时常量）**
- **生命周期**：`const` 是纯粹的编译时常量，它的值在编译时被直接内联（inline）到使用它的地方，没有固定的内存地址。
- **存储**：不占用运行时内存，因为它会被直接替换为字面值。
- **可变性**：总是不可变的（不能用 `mut` 修饰）。
- **使用场景**：适用于定义在编译时已知的常量值（如数学常数、配置参数等）。
- **示例**：
  ```rust
  const PI: f64 = 3.14159;
  const MAX_SIZE: usize = 100;

  // 使用时会直接替换为字面值，比如 `let x = 3.14159;`
  let x = PI;
  ```

---

### **2. `static`（全局静态变量）**
- **生命周期**：`static` 是全局变量，它的值在程序的整个生命周期中存在，并且有固定的内存地址。
- **存储**：占用运行时内存，所有引用都指向同一块内存。
- **可变性**：
  - 默认不可变，但可以用 `static mut` 声明可变静态变量（但使用 `static mut` 是 `unsafe` 的，需谨慎）。
- **线程安全**：
  - 不可变的 `static` 是线程安全的。
  - 可变的 `static mut` 是非线程安全的，需要在 `unsafe` 块中访问。
- **使用场景**：适用于需要全局共享的状态（如全局配置、单例模式等）。
- **示例**：
  ```rust
  static APP_NAME: &str = "MyApp";
  static mut COUNTER: u32 = 0;

  fn main() {
      println!("{}", APP_NAME); // 安全访问不可变 static

      unsafe {
          COUNTER += 1; // 可变 static 必须用 unsafe
      }
  }
  ```

---

### **关键区别总结**
| 特性                | `const`                     | `static`                     |
|---------------------|----------------------------|-----------------------------|
| **内存地址**         | 无（编译时内联）           | 有（固定内存地址）          |
| **生命周期**         | 编译时替换                 | 整个程序生命周期            |
| **可变性**           | 永远不可变                 | 默认不可变，可声明为 `mut`（需 `unsafe`） |
| **线程安全**         | 是                         | 不可变的是安全的，可变的需要 `unsafe` |
| **适用场景**         | 编译时常量（如数学公式）   | 全局共享状态（如计数器、配置） |

---

### **如何选择？**
- 优先使用 `const`：如果值可以在编译时确定且不需要全局存储。
- 使用 `static`：如果需要全局共享状态或有固定的内存地址（如 FFI 交互）。
- 避免 `static mut`：推荐用 `Atomic` 类型或 `Mutex` 实现线程安全的可变全局状态。

#### 示例（推荐替代 `static mut` 的方式）：
```rust
use std::sync::atomic::{AtomicU32, Ordering};

static COUNTER: AtomicU32 = AtomicU32::new(0);

fn main() {
    COUNTER.fetch_add(1, Ordering::SeqCst); // 线程安全操作
    println!("Counter: {}", COUNTER.load(Ordering::SeqCst));
}
```

希望这能帮你理清 `const` 和 `static` 的区别！

通常情况下，编译时已知且全局不可变，则使用const, 不满足此条件，但需要全局共享，如配置信息，则使用static



